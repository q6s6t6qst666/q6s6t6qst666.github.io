<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Java内部类，外部类，嵌套类，静态类</title>
      <link href="/2023/04/26/%E5%85%B3%E4%BA%8EJava%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%B5%8C%E5%A5%97%E7%B1%BB%EF%BC%8C%E9%9D%99%E6%80%81%E7%B1%BB/"/>
      <url>/2023/04/26/%E5%85%B3%E4%BA%8EJava%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%B5%8C%E5%A5%97%E7%B1%BB%EF%BC%8C%E9%9D%99%E6%80%81%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><hr><p>非静态和嵌套的类称之为内部类。请注意，我们不能在不创建外部类实例的情况下创建内部类实例。在不使用对外部类实例的引用的情况下，内部类的实例可以访问外部类的成员。而这使得程序更为简单明了</p><hr><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><hr><p>静态和嵌套的类称之为静态类。可以在不创建外部类实例的情况下创建静态类实例。</p><hr><h2 id="外部类"><a href="#外部类" class="headerlink" title="外部类"></a>外部类</h2><hr><p>包含了嵌套类定义的类被称为外部类</p><hr><h2 id="嵌套类-内部类和静态类的超集"><a href="#嵌套类-内部类和静态类的超集" class="headerlink" title="嵌套类(内部类和静态类的超集)"></a>嵌套类(内部类和静态类的超集)</h2><hr><p>Java允许我们在一个类中定义另一个类，这个位于其他类之中的类称之为嵌套类。该类可以是静态的，也可以是非静态的，二者之间最大的区别在于：</p><ul><li>静态类的外部类的实例创建不是的创建该类的实例的先决条件</li><li>外部类的非静态成员不能被静态类的任何方法访问</li><li>外部类的所有成员都可以被内部类的非静态方法访问</li><li>内部类不能被外部静态方法实例化，静态类可以</li></ul><hr><p>注意事项</p><ul><li>所有静态类都是嵌套类，反之则不然。</li><li>它只能访问外部类的静态成员。</li><li>不能在静态类中访问非静态变量和实例方法。 如果您尝试从静态字段访问非静态引用，则会抛出错误：无法对非静态字段进行静态引用（Non-static field ‘nonStatic’ cannot be referenced from a static context  ）。</li><li>我们可以在静态类中创建静态块、变量和方法。<br>一个类可以有多个静态类。</li><li>如果静态类在静态块内，我们将无法访问它。</li><li>一个静态类中可以有任意数量的静态类。</li><li>只加载一次，生命周期与JVM一致</li><li>使用方式上不依赖于外部类的实例，类似于其他静态成员的使用方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java Comparable</title>
      <link href="/2023/04/25/%E5%85%B3%E4%BA%8EJava%20Comparable%20%E4%B8%8E%20Comparator/"/>
      <url>/2023/04/25/%E5%85%B3%E4%BA%8EJava%20Comparable%20%E4%B8%8E%20Comparator/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr><p>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。可以使用Arrays.sort()对改类进行排序</p><hr><h2 id="1-Comparable接口"><a href="#1-Comparable接口" class="headerlink" title="1.Comparable接口"></a>1.Comparable接口</h2><p>使用场景：假如说我们有这样一个需求，需要设计一个Person类，有两个属性：姓名（name）、年龄（age），按照年龄的大小进行排序，那么实现可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名:&quot;</span>+name+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;年龄:&quot;</span>+age+<span class="string">&quot;;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age&gt;o.age)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.age&lt;o.age)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当然也可以这样实现</span></span><br><span class="line">        <span class="comment">// return Integer.compare(this.age, o.age);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Person []persons = <span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">15</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">25</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(persons);</span><br><span class="line">    System.out.println(Arrays.toString(persons));</span><br><span class="line">    System.out.println(persons[<span class="number">0</span>]==persons[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(persons[<span class="number">0</span>].equals(persons[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[姓名:王五,年龄:<span class="number">10</span>;, 姓名:张三,年龄:<span class="number">15</span>;, 姓名:李四,年龄:<span class="number">15</span>;, 姓名:赵刘,年龄:<span class="number">45</span>;]</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意细节：</p><ul><li><font color = "red"> Comparable&lt;T&gt; </font>接口里面有一个泛型T，T的选择为可以与之比较的对象的类型，一般就是实现该接口类的本身，可以这样想和Person类比较的当然是Person本身了</li><li><font color = "red"> Comparable&lt;T&gt; </font>只是在Arrays里面起作用，其他地方目前我并没有发现什么作用，包括运算符和equals上，这个接口也不起什么作用</li></ul><h2 id="2-Comparator接口"><a href="#2-Comparator接口" class="headerlink" title="2.Comparator接口"></a>2.Comparator接口</h2><hr><p>Comparator也是一个比较器，但是属于挽救设计的一种，一般来说尽量减少使用</p><hr><p>使用场景：假如说我们有这样一个需求，需要对Person类的年龄进行排序，Person类有两个属性：姓名（name）、年龄（age），但是Person类是别人写好的，里面没有Comparable接口，如果在不允许改变源代码的情况下，我们可以使用Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别人定义好的，不允许修改源代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名:&quot;</span>+name+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;年龄:&quot;</span>+age+<span class="string">&quot;;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">PersonComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Person&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.age, o2.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Person []persons = <span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">15</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">15</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;赵刘&quot;</span>,<span class="number">45</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(persons,<span class="keyword">new</span> <span class="title class_">PersonComparator</span>());</span><br><span class="line">    System.out.println(Arrays.toString(persons));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[姓名:王五,年龄:<span class="number">10</span>;, 姓名:张三,年龄:<span class="number">15</span>;, 姓名:李四,年龄:<span class="number">15</span>;, 姓名:赵刘,年龄:<span class="number">45</span>;]</span><br></pre></td></tr></table></figure><p>注意细节：</p><ul><li><font color = "red"> Comparator&lt;T&gt; </font>其中泛型T为比较器可以比较的对象的类型，在这里面为Person</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Comparable和Comparator的区别：</p><ul><li><font color = "red"> java.lang.Comparable </font>：在类定义的时候，可以实现好的接口，里面有compareTo这个方法需要实现。</li><li><font color = "red"> java.lang.java.util.Comparator </font>:是挽救的比较接口，需要单独定义一个比较类，里面有compare比较方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java lambda表达式</title>
      <link href="/2023/04/25/%E5%85%B3%E4%BA%8EJava%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/04/25/%E5%85%B3%E4%BA%8EJava%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="函数式接口：只有一个抽象方法的接口"><a href="#函数式接口：只有一个抽象方法的接口" class="headerlink" title="函数式接口：只有一个抽象方法的接口"></a>函数式接口：只有一个抽象方法的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个函数式接口。只有一个抽象方法的接口就是函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILike</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testLambda</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java类的组合</title>
      <link href="/2023/04/11/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/"/>
      <url>/2023/04/11/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="组合的概念"><a href="#组合的概念" class="headerlink" title="组合的概念"></a>组合的概念</h1><p>Java的类中可以有其他类的对象作为成员，这便是类的组合</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的正则表达式</title>
      <link href="/2023/04/10/Java%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/04/10/Java%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><ul><li>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</li><li>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式</li></ul></li><li><p>Matcher 类：</p><p>  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java单例模式</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java异常</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%BC%82%E5%B8%B8%20/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%BC%82%E5%B8%B8%20/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><ul><li>异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止</li><li>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行</li><li><strong>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象</strong></li><li>Java为异常设计了一套异常处理机制，当程序运行过程中发生一些异常情况时，程序不会返回任何值，而是抛出封装了错误信息的异常对象。这样保证程序代码更加优雅，并提高程序的健壮性。 为什么要设计异常呢？首先，引入异常之后，我们就可以把错误的代码从正常代码中分离出来进行单独处理，这样使代码变得更加整洁；其次，当出现一些特殊情况时，我们还可以抛出一个检查异常，告知调用者让其处理。</li></ul><h2 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h2><p>异常类的整体呈继承关系</p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><hr><p>所有的异常都是从Throwable继承而来的，是所有所有错误与异常的超类。Throwable包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace()等接口用于获取堆栈跟踪数据等信息</p><hr><p>Throwable体系下包含有两个子类，Error（错误）和Exception（异常），它们通常用于指示发生了异常情况。二者都是 Java 异常处理的重要子类，各自都包含大量子类</p><h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error(错误)"></a>Error(错误)</h3><ul><li>定义：Error类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。大多数错误与代码编写者执行的操作无关，而是表示代码运行时 JVM出现的问题</li><li>特点：对于所有的编译时期的错误以及系统错误都是通过Error抛出的。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时。通常有如Virtual MachineError （虚拟机运行错误）等。当 JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError（内存不出错误），还有StackOverflowError（栈溢出错误）等。这些异常发生时，JVM一般会选择线程终止</li><li>注意：这些错误是不受检查的，非代码性错误，不可查的。因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。因此，当此类错误发生时，应用程序不应该去处理此类错误</li></ul><h3 id="Exception-异常-（出现异常后程序不再执行）"><a href="#Exception-异常-（出现异常后程序不再执行）" class="headerlink" title="Exception(异常)（出现异常后程序不再执行）"></a>Exception(异常)（出现异常后程序不再执行）</h3><hr><p>Exception 是另外一个非常重要的异常子类。程序本身可以捕获并且可以处理异常。这类异常一旦出现，我们就要对代码进行更正，修复程序。Exception这种异常又分为两类：运行时异常和编译时异常</p><hr><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul><li>定义：RuntimeException 类及其子类异常，如NullPointerException （空指针异常）、IndexOutOfBoundsException （下目标越界异常）等，表示 JVM在运行期间可能出现的异常</li><li>特点：此类异常，Java 编译器不会检查它，属于不受检查的异常。一般是由程序逻辑错误引起的，此类程序应该从逻辑角度尽可能避免这类异常的发生。而当程序中可能出现这类异常，即使没有用try-catch 语句捕获它，也没有用throws 子句声明抛出它，也会编译通过。在程序中<strong>可以选择捕获处理，也可以不处理</strong>（不处理的话jvm会帮你处理）。如果产生运行异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</li><li>注意：<strong>RuntimeException 异常会由JVM自动抛出并自动捕获</strong>（<strong>就算我们没写异常捕获语句运行时也会抛出错误！！</strong>），此类异常的出现绝大多数情况是代码本身有问题，应该从逻辑上去解决并改进代码。 这里我们来看下运行时异常是怎样的，这里我想说下，出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。然后看是什么异常。</li><li>那我们什么都没有处理，那出现异常时，是谁处理了这个异常呢？ 是<strong>JVM的默认处理：把异常的名称,原因,位置等信息输出在控制台</strong>，但是呢程序就不能继续执行了</li></ul><h4 id="非运行时异常（编译时异常）"><a href="#非运行时异常（编译时异常）" class="headerlink" title="非运行时异常（编译时异常）"></a>非运行时异常（编译时异常）</h4><ul><li>定义：Exception中除 RuntimeException 及其子类之外的异常</li><li>特点：此类异常， Java 编译器会检查它。如果程序中出现此类异常，从程序语法角度讲是必须进行处理得异常。例如：ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws 进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译</li><li>注意：在程序中，通常我们不会自定义该类异常，而是直接使用系统提供的异常类。<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>。所以我们如果是编译时异常，在编译时期就报错了，必须处理这个异常，不然程序不能编译通过</li></ul><h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><p>通常，Java的异常（Throwable）分为受检异常（checked exceptions）和非受检异常（unchecked exceptions）</p><h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h4><hr><p>编译器要求必须处理得异常</p><hr><ul><li>正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除了Exception中的 RuntimeException 及其子类以外，其他的 Exception类及其子类异常（非运行时期异常）都属于受检异常</li><li>这种异常编译器会检查它，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过</li></ul><h4 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h4><hr><p>编译器不会进行检查并且不要求必须处理的异常</p><hr><ul><li>此类异常，就是当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws 抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException 极其子类）和错误（ Error）。RuntimeException 发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException</li></ul><h2 id="异常的处理机制（重点）"><a href="#异常的处理机制（重点）" class="headerlink" title="异常的处理机制（重点）"></a>异常的处理机制（重点）</h2><hr><p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常</p><hr><h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><ul><li>在Java中，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口</li><li>在 Java 中，每个异常都是一个对象，它是 Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理</li><li>Java 的异常处理涉及了 5 个关键词：try、catch、 finally、throw 和throws</li><li>在Java应用中，异常的处理机制分为<strong>声明异常throws，抛出异常throw 和捕获异常try、catch、 finally</strong></li></ul><h3 id="异常处理的关键词"><a href="#异常处理的关键词" class="headerlink" title="异常处理的关键词"></a>异常处理的关键词</h3><ul><li>throw ： 用于抛出异常</li><li>try ： 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出</li><li>catch ：用于捕获异常。catch用来捕获try语句块中发生的异常</li><li>finally ： finally语句块总是会被执行。它主要用于回收在try块里打开的资源(如数据库连接、网络连接和磁盘文件)。 <strong>注意：只有finally块执行完成之后，才会回来执行try或者catch块中的return或者throw 语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止</strong></li><li>throws： 用在方法签名中，用于声明该方法可能抛出的异常</li></ul><h3 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h3><hr><p>在自定义的异常中与try-catch搭配使用 ，抛出的异常要被catch才能自行处理（用于想要自定义怎么处理异常的时候），不然会被jvm自动处理</p><hr><ul><li><p>使用时机</p><ul><li>在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者</li><li>或者当你觉得解决不了某些异常问题，且不需要调用者处理，那么你也可以抛出异常</li></ul></li><li><p>throw的作用：在方法内部抛出一个Throwable 类型的异常。任何Java代码都可以通过throw语句抛出异常</p></li><li><p>具体如何抛出一个异常呢</p><ul><li>创建一个异常对象。封装一些提示信息(信息可以自己编写)</li><li>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行</li><li>定义格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure></li><li>eg：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> getElement(arr, index);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//判断索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">                判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">                这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;老弟，你的索引越界了，别这么干&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: 老弟，你的索引越界了，别这么干</span><br><span class="line">at com.it.test2.ThrowDemo.getElement(ThrowDemo.java:<span class="number">25</span>)</span><br><span class="line">at com.it.test2.ThrowDemo.main(ThrowDemo.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>注意：所以如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理</p><h3 id="3-4-声明异常throws"><a href="#3-4-声明异常throws" class="headerlink" title="3.4 声明异常throws"></a>3.4 声明异常throws</h3><hr><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时它可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理</p><hr><ul><li>声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了<strong>编译时异常</strong>，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理</li></ul><p>关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)</p><ul><li>定义格式： throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>其他</p><ul><li>个人猜测自定义异常时的有参构造是给jvm处理异常的时候用的</li><li>编译时异常时合理的，被预料到的，可以用try-catch解决，解决后可执行后面的代码</li><li>运行时异常是不合理的需要从代码层面解决</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java注解与反射</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其实同 classs 和 interface 一样，注解也属于一种类型</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li>@override：此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个发方法声明</li><li>@Deprecated：此注释可用于修饰方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者有更好的选择</li><li>@SupressWarnings：用来抑制编译时的警告信息（<strong>注意：此注释需要添加一个参数才能正确使用</strong>）<ul><li>@SupressWarnings(“all”)</li><li>@SupressWarnings(“unchecked”)</li><li>@SupressWarnings(value={“unchecked”,”deprecation”})</li><li>等等……</li></ul></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li>使用 @interface 来自定义注解，其自动继承java.lang.annotation.Annotation接口</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数类型（返回值只能是基本类型，Class，String，enum）</li><li>可以用default来声明参数的默认值</li><li>如果注解只有一个参数成员，一般参数名是value</li><li>注解元素必须要有值，定义注解元素是，经常使用空 字符串/0 作为默认值</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面</p><p>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种(这些类在包java.lang.annotation中)</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明@Retention也需要参数，类似于@SupressWarnings</p><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间</p><p>它的取值如下：</p><table><thead><tr><th align="left">RetentionPolicy.SOURCE</th><th align="center">注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视</th></tr></thead><tbody><tr><td align="left">RetentionPolicy.CLASS</td><td align="center">注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</td></tr><tr><td align="left">RetentionPolicy.RUNTIME</td><td align="center">注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</td></tr></tbody></table><ul><li><strong>SOURCE &lt; CLASS &lt; RUNTIME</strong></li></ul><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target 指定了注解运用的地方，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景</p><p>@Target源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Module declaration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MODULE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明@Target也需要参数，类似于@SupressWarnings</p><p>它的取值如下：</p><table><thead><tr><th align="left">ElementType.ANNOTATION_TYPE</th><th align="center">可以给一个注解进行注解</th></tr></thead><tbody><tr><td align="left">ElementType.CONSTRUCTOR</td><td align="center">可以给构造方法进行注解</td></tr><tr><td align="left">ElementType.FIELD</td><td align="center">可以给属性进行注解</td></tr><tr><td align="left">ElementType.LOCAL_VARIABLE</td><td align="center">可以给局部变量进行注解</td></tr><tr><td align="left">ElementType.METHOD</td><td align="center">可以给方法进行注解</td></tr><tr><td align="left">ElementType.PACKAGE</td><td align="center">可以给一个包进行注解</td></tr><tr><td align="left">ElementType.PARAMETER</td><td align="center">可以给一个方法内的参数进行注解</td></tr><tr><td align="left">ElementType.TYPE</td><td align="center">可以给一个类型进行注解，比如类、接口、枚举</td></tr></tbody></table><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解</p><p>举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>它的作用是能够将注解中的元素包含到 <strong>Javadoc</strong> 中去</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><h2 id="反射（Java-Reflection）"><a href="#反射（Java-Reflection）" class="headerlink" title="反射（Java Reflection）"></a>反射（Java Reflection）</h2><p>反射机制允许程序在执行期借助于Reflection API获得任何类的内部信息，并且能直接操作任意对象的内部属性及方法</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子可以看到类的结构）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String（包名.类名）&quot;</span>);</span><br></pre></td></tr></table></figure><p>优点：动态创建对象和编译，灵活</p><p>缺点：对性能有影响，使用反射基本上是解释操作</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java策略模式</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java装箱与拆箱</title>
      <link href="/2023/04/05/%E5%85%B3%E4%BA%8Ejava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
      <url>/2023/04/05/%E5%85%B3%E4%BA%8Ejava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是自动装箱与拆箱"><a href="#什么是自动装箱与拆箱" class="headerlink" title="什么是自动装箱与拆箱"></a>什么是自动装箱与拆箱</h2><h4 id="1-来由"><a href="#1-来由" class="headerlink" title="1. 来由"></a>1. 来由</h4><ul><li>Java是一种面向对象编程的语言，但他同时也提供了基本数据类型，提供基本数据类型是出于性能方面的考虑：<strong>因为使用对象来处理即使是最简单的计算，系统也销也比较大</strong>(why?)</li><li>Java中的基本数据类型没有方法和属性，但是在特定场景下，我们必须要利用对象的相关属性，而包装类就是为了让基本数据类型拥有方法和属性，实现对象化交互</li></ul><h4 id="2-Java中的基本数据类型"><a href="#2-Java中的基本数据类型" class="headerlink" title="2. Java中的基本数据类型"></a>2. Java中的基本数据类型</h4><p>java中有8种基本数据类型，分别为：</p><ul><li>数字类型（6种）<ul><li>整型<ul><li>byte——————–1字节= 8bit</li><li>short——————-2字节=16bit</li><li>int———————–4字节= 32bit</li><li>long——————–8字节= 64bit</li></ul></li><li>浮点型<ul><li>float——————-4字节=32bit</li><li>double—————-8字节=64bit</li></ul></li></ul></li><li>字符类型（1种）：char—–2字节=16bit</li><li>boolean类型（1种）：boolean类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。boolean类型占用存储空间官方未定义</li></ul><h5 id="注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c-c-不同）"><a href="#注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c-c-不同）" class="headerlink" title="注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c/c++不同）"></a>注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c/c++不同）</h5><h4 id="3-类型封装器（包装类）"><a href="#3-类型封装器（包装类）" class="headerlink" title="3. 类型封装器（包装类）"></a>3. 类型封装器（包装类）</h4><p>上面说的八种基本数据类型都分别都有对应的包装类，如下表：需要了解的是这些包装类提供了大量的方法，通过这些方法可以完全将基本类型集成到Java的对象层次中</p><h4 id="4-自动装箱与拆箱"><a href="#4-自动装箱与拆箱" class="headerlink" title="4. 自动装箱与拆箱"></a>4. 自动装箱与拆箱</h4><h5 id="4-1-自动装箱"><a href="#4-1-自动装箱" class="headerlink" title="4.1 自动装箱"></a>4.1 自动装箱</h5><p>装箱 ：就是将基本数据类型用他们对应的包装类包装起来。如下：</p><h5 id="4-1-自动拆箱"><a href="#4-1-自动拆箱" class="headerlink" title="4.1 自动拆箱"></a>4.1 自动拆箱</h5><p>拆箱 ： 就是将包装类型转换为基本数据类型。如下</p><p>因此总结一下装箱和拆箱的实现过程就是：</p><p>装箱过程是通过调用包装类的valueOf方法实现的，而拆箱过程是通过调用包装类的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><p>注意：我们要了解的是，频繁的装箱拆箱的话，会增加内存的消耗，影响性能</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java枚举类</title>
      <link href="/2023/04/04/%E5%85%B3%E4%BA%8EJava%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2023/04/04/%E5%85%B3%E4%BA%8EJava%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-枚举-enum"><a href="#Java-枚举-enum" class="headerlink" title="Java 枚举(enum)"></a>Java 枚举(enum)</h1><h3 id="枚举类的目的"><a href="#枚举类的目的" class="headerlink" title="枚举类的目的"></a>枚举类的目的</h3><p><strong>实现一个类只有固定的几个对象，而且不能随意创建对象</strong></p><h4 id="枚举类的早期实现方式"><a href="#枚举类的早期实现方式" class="headerlink" title="枚举类的早期实现方式"></a>枚举类的早期实现方式</h4><ul><li>构造器加private私有化(使用私有构造方法后类外无法访问构造方法，从而无法创建类)</li><li>本类内部创建一组常量对象，并添加public static修饰符，对外暴露这些常量对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有固定4个对象的季节类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String seasonName;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在JDK1.5之后，Java支持enum关键字来快速的定义枚举类型</li><li>枚举类型本质上也是一种类，只不过是这个类的对象是固定的几个，而不能随意让用户创建</li></ul><h3 id="枚举类的定义"><a href="#枚举类的定义" class="headerlink" title="枚举类的定义"></a>枚举类的定义</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的要求和特点"><a href="#枚举类的要求和特点" class="headerlink" title="枚举类的要求和特点"></a>枚举类的要求和特点</h3><ul><li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写</li><li>如果常量对象列表后面没有其他代码，那么“；”<strong>可以省略</strong>，否则不可以省略“；”</li><li><strong>编译器给枚举类默认提供private的无参构造</strong>（枚举类依靠此来达成“实现一个类只有固定的几个对象，而且不能随意创建对象”的目的）</li><li>如果需要也可以定义有参构造，默认也是private修饰，常量对象名后面加(实参列表)调用有参构造器</li><li>枚举类默认继承自java.lang.Enum类，不能再继承其他的类型；枚举类默认是final修饰的也不能被继承</li><li>JDK1.5之后switch，提供支持枚举类型，case后面可以写枚举常量名</li><li>枚举类型如有其它属性，建议这些属性也声明为final的，因为<strong>常量对象在逻辑意义上应该不可变</strong></li><li>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它<br>枚举类eg:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">   &#123;</span><br><span class="line">       RED, GREEN, BLUE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>枚举类的内部实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的常用方法"><a href="#枚举类的常用方法" class="headerlink" title="枚举类的常用方法"></a>枚举类的常用方法</h3></li><li>values()：以数组形式返回枚举类型的所有成员</li><li>valueOf()：将普通字符串转换为枚举实例</li><li>ordinal()：获取枚举成员的索引位置</li><li>toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</li></ul><p>测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RED at index <span class="number">0</span></span><br><span class="line">GREEN at index <span class="number">1</span></span><br><span class="line">BLUE at index <span class="number">2</span></span><br><span class="line">RED</span><br></pre></td></tr></table></figure><ul><li>枚举常量也可以有自己的方法。此时要注意<strong>必须在枚举实例的最后一个成员后添加分号</strong>，而且<strong>必须先定义枚举实例</strong></li></ul><h3 id="枚举类的用法"><a href="#枚举类的用法" class="headerlink" title="枚举类的用法"></a>枚举类的用法</h3><ul><li>接口组织枚举</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java抽象类&amp;interface</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;interface/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;interface/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><ul><li>在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>而抽象方法,是指没有方法体的方法,同时抽象方法还必须使用关键字abstract做修饰。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在后日子类进行重用，进行具体化</li><li>所以，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法</li><li>拥有抽象方法的类就是抽象类（但抽象类中也可以不包含抽象方法），抽象类要使用abstract关键字声明<h4 id="抽象类的特性和使用"><a href="#抽象类的特性和使用" class="headerlink" title="抽象类的特性和使用"></a>抽象类的特性和使用</h4></li><li>抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了</li><li>抽象类的使用必须有子类，使用extends继承，一个子类只能继承一个抽象类</li><li>子类（如果不是抽象类）则必须<strong>覆写</strong>抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）</li><li>抽象类可以不包含抽象方法，但如果类中包含抽象方法，就必须将该类声明为抽象类<h4 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h4></li><li>抽象类可以有构造方法，且依然满足先执行父类构造，再执行子类构造的顺序</li><li>抽象类不能使用final声明，因为抽象类必须有子类，而final定义的类不能有子类</li><li>外部抽象类不允许使用static声明，而内部的抽象类可以使用static声明。<br>使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称</li><li>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2></li><li>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，<strong>Java不支持多重继承</strong>。有了接口，就可以得到<strong>多重继承</strong>的效果</li><li>从本质上讲，接口是一种<strong>特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现</strong></li><li>也可以理解成：<strong>接口(interface)是抽象方法和常量值的定义的集合</strong></li><li>接口也可以继承另一个接口，使用extends关键字</li><li>接口方法没有主体-主体由”implement”类提供<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4></li><li>如果一个类中，既有抽象方法，又有非抽象方法，那么该类只能定义为抽象类，不能定义为接口</li><li>如果一个类中，只有抽象方法，没有非抽象方法，那么该类可以定义为接口，一般就定义为接口</li><li>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类<h4 id="接口中的成员变量"><a href="#接口中的成员变量" class="headerlink" title="接口中的成员变量"></a>接口中的成员变量</h4></li><li>方法和属性默认都是public修饰，也可以使用protected，但不能用private（private无法继承）</li><li>所有的属性都是静态的常量，默认省略了static和final修饰符，属性的值必须实例化（初始化）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java类继承</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="属性隐藏"><a href="#属性隐藏" class="headerlink" title="属性隐藏"></a>属性隐藏</h2><p>子类中声明了与超类中相同的成员变量名</p><ul><li>从超类继承的变量将被隐藏</li><li>子类拥有了两个相同名字的变量，一个继承自超类，另一个由自己声明</li><li>当子类执行继承自超类的操作时，处理的是继承自超类的变量，而当子类执行它</li><li>自己声明的方法时，所操作的就是它自己声明的变量<h2 id="访问被隐藏的超类属性"><a href="#访问被隐藏的超类属性" class="headerlink" title="访问被隐藏的超类属性"></a>访问被隐藏的超类属性</h2>本类中声明的方法使用“super.属性”访问从超类继承的属性<h2 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h2><h3 id="如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖"><a href="#如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖" class="headerlink" title="如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖"></a>如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖</h3></li><li>覆盖方法的返回类型，方法名称，参数的个数及类型必须和被覆盖的方法一摸一样</li><li>覆盖方法的访问权限可以比被覆盖的宽松，但是不能更为严格<h3 id="Java-Override注解"><a href="#Java-Override注解" class="headerlink" title="Java @Override注解"></a>Java @Override注解</h3>@Override 的作用是告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否则就会编译出错。这样可以帮助程序员避免一些低级错误<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">t0String</span><span class="params">()</span> &#123; <span class="comment">//toString()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述代码第 6 行是重写 Object 类的 toString() 方法，该方法使用 @Override 注解。如果 toString() 不小心写成了 t0String()，那么程序会发生编译错误。会有如下的代码提示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型为 Person 的方法t0String()必须覆盖或实现超类型方法</span><br></pre></td></tr></table></figure><h3 id="方法覆盖的注意事项"><a href="#方法覆盖的注意事项" class="headerlink" title="方法覆盖的注意事项"></a>方法覆盖的注意事项</h3></li><li>不能覆盖的方法<ul><li>基类中声明为final的终结方法</li><li>基类中声明为static 的静态方法</li></ul></li><li>调用被覆盖的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.overriddenMethodName();</span><br></pre></td></tr></table></figure><h2 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h2><h3 id="有继承时子类的构造方法遵循以下的原则"><a href="#有继承时子类的构造方法遵循以下的原则" class="headerlink" title="有继承时子类的构造方法遵循以下的原则"></a>有继承时子类的构造方法遵循以下的原则</h3></li><li>子类不能从超类继承构造方法</li><li>最好在子类的构造方法中使用super关键字显式调用超类的某个构造方法，调用语句必须出现在子类构造方法的第一行</li><li>如子类构造方法体中没有显式调用超类构造方法，则系统在执行子类的构造方法时会自动调用超类的默认构造方法（即无参的构造方法）<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2></li><li>所有Java类的直接或间接超类</li><li>如果一个类没有继承任何超类，那么就隐含直接继承了Object类<h3 id="相等和同一"><a href="#相等和同一" class="headerlink" title="相等和同一"></a>相等和同一</h3></li><li>两个对象具有相同的类型，及相同的属性值，则称二者相等(equal)</li><li>如果两个引用变量指向的是同一个对象，则称这两个引用变量同一(identical)</li><li>在Object类中声明的equals()方法功能是比较两个对象引用是否指向同一对象，而不是比较两个引用指向的对象是否相等</li><li>比较运算符“==” 判断的是这两个对象是否同一</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java泛型</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><ul><li>使用类型参数，使程序更为通用，适用于处理不同类型的数据</li><li>泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数</li><li>可以声明泛型类、泛型方法和泛型接口</li><li>没有泛型的时候使用集合<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">names</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        names.add(<span class="string">&quot;qst&quot;</span>);</span><br><span class="line">        names.add(<span class="number">123</span>); <span class="comment">//编译正常</span></span><br><span class="line">        System.out.println(names.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></li><li>有泛型的情况下使用集合<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;qst&quot;</span>);</span><br><span class="line">        names.add(<span class="number">123</span>); <span class="comment">//编译不通过</span></span><br><span class="line">        System.out.println(names.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>有了泛型后，定义好的集合names在编译的时候add(123)就会编译不通过<br>相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性</li></ul><h3 id="泛型中KTVE的含义"><a href="#泛型中KTVE的含义" class="headerlink" title="泛型中KTVE的含义"></a>泛型中KTVE的含义</h3><ul><li>T: Type任意类型</li><li>E：Element (在集合中使用，因为集合中存放的是元素)</li><li>K：Key（键）</li><li>V：Value（值）</li><li>N：Number（数值类型）N：Number（数值类型）</li><li>？：表示不确定的java类型</li></ul><hr><h4 id="注意：-泛型类不支持基本数据类型"><a href="#注意：-泛型类不支持基本数据类型" class="headerlink" title="注意： 泛型类不支持基本数据类型"></a>注意： 泛型类不支持基本数据类型</h4><hr><h3 id="泛型类派生子类"><a href="#泛型类派生子类" class="headerlink" title="泛型类派生子类"></a>泛型类派生子类</h3><ul><li>子类是泛型类：子类数据类型中要有父类的数据类型</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span>&lt;T, E, k, ...&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类不是泛型类：要明确父类的数据类型(不指明就默认Object数据类型)</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 &lt;泛型标识, 泛型标识, ...&gt;&#123;</span><br><span class="line">    泛型标识 方法名();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口的使用"><a href="#泛型接口的使用" class="headerlink" title="泛型接口的使用"></a>泛型接口的使用</h4><ol><li>实现类不是泛型类，接口要明确数据类型(不指明就默认Object数据类型)</li><li>实现类也是泛型类，实现类的接口要有泛型类的泛型标识 </li></ol><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在调用方法的时候指明泛型的具体类型</p><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T, E, ...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line"><span class="comment">//泛型标识可以与类内的相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错"><a href="#注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错" class="headerlink" title="注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错"></a>注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错</h4><hr><h3 id="泛型的可变参数"><a href="#泛型的可变参数" class="headerlink" title="泛型的可变参数"></a>泛型的可变参数</h3><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E... e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E e1 : e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><ul><li>类型通配符 “?” 用来代替具体的类型实参</li><li>类型通配符是实参类型，不是形参类型<br>eg:</li></ul><p>定义Box类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;Number&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>修改test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line">        Box&lt;Integer&gt; box2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box2.setFirst(<span class="number">200</span>);</span><br><span class="line">        showBox(box2);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;Number&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现代码第8行报错，原因是形参是Box<Number>类型，实参却是Box<Integer>类型</p><p>改正test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line">        Box&lt;Integer&gt; box2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box2.setFirst(<span class="number">200</span>);</span><br><span class="line">        showBox(box2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;?&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();<span class="comment">//注意</span></span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型通配符的上限"><a href="#类型通配符的上限" class="headerlink" title="类型通配符的上限"></a>类型通配符的上限</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? extends 实参类型&gt;</span><br></pre></td></tr></table></figure><p>要求该泛型类型只能是实参类型或者实参类型的子类型</p><hr><p>注意：上线通配符的集合不能添加元素</p><hr><h4 id="类型通配符的下限"><a href="#类型通配符的下限" class="headerlink" title="类型通配符的下限"></a>类型通配符的下限</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? <span class="built_in">super</span> 实参类型&gt;</span><br></pre></td></tr></table></figure><p>要求该泛型类型只能是实参类型或者实参类型的父类型</p><hr><p>注意：下限通配符的集合可以添加元素，但是不能保证对元素类型的约束（可以填充子类类型）</p><hr><h4 id="与C-对比"><a href="#与C-对比" class="headerlink" title="与C++对比"></a>与C++对比</h4><ul><li>Java中的泛型与C++中的类模版，它们的作用类似，但是编译解析的方式不同。Java泛型类的目标代码只会生成一份，牺牲的是运行速度</li><li>C++的类模板针对不同的模板参数静态实例化，目标代码体积会稍大一些，但是运行速度快</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2023/03/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>线程是调度的基本单位<br>一个进程可能包含多个线程，一个进程的多个线程共享进程的资源<br>进程是操作系统分配资源的基本单位<br>线程在进程的基础上进一步提高了系统的并发性<br>进程相对线程，降低了创建调度和撤销的成本</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java代码块</title>
      <link href="/2023/03/27/%E5%85%B3%E4%BA%8EJava%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2023/03/27/%E5%85%B3%E4%BA%8EJava%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="static代码块和构造代码块"><a href="#static代码块和构造代码块" class="headerlink" title="static代码块和构造代码块"></a>static代码块和构造代码块</h1><p>结论:<strong>static代码块伴随着类的加载，只在类第一次被加载的时候调用一次<br>构造代码块是用来给新建的对象进行初始化的，构造几个对象，就调用多少次，是通用的<br>局部代码块是用于特定局部的一种代码，在执行完局部代码之后，就被释放掉了</strong><br></p><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCode</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// static 代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construction code &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    StaticCode(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        System.out.println(<span class="string">&quot;construction method： &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age=<span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;method show:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"><span class="keyword">import</span> edu.bupt.qst.StaticCode;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        StaticCode p2=<span class="keyword">new</span> <span class="title class_">StaticCode</span>(<span class="number">40</span>);</span><br><span class="line">        StaticCode p1=<span class="keyword">new</span> <span class="title class_">StaticCode</span>(<span class="number">20</span>);</span><br><span class="line">        p1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/ppgUFds"><img src="https://s1.ax1x.com/2023/03/29/ppgUFds.png" alt="ppgUFds.png"></a></p><h1 id="构造代码块和构造方法"><a href="#构造代码块和构造方法" class="headerlink" title="构造代码块和构造方法"></a>构造代码块和构造方法</h1><p>结论:<strong><br>构造代码块<br>特点：对象一建立就运行了，而且优先于构造函数执行<br>作用：给对象进行初始化<br>构造代码块与构造方法区别：<br>构造代码块是给所有的对象进行统一的初始化(每次创建对象必调用)<br>构造方法是对应的对象进行初始化</strong></p><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&quot;小虎鲸&quot;</span>);</span><br><span class="line">        System.out.println(A.name);</span><br><span class="line">        System.out.println(B.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    Person2() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    Person2(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgloc.com/i/ikebHy"><img src="https://i.328888.xyz/2023/03/29/ikebHy.png" alt="ikebHy.png"></a></p><h1 id="静态-内部类-方法"><a href="#静态-内部类-方法" class="headerlink" title="(静态)内部类/方法"></a>(静态)内部类/方法</h1><p>静态内部类/方法 只能访问外部类中的静态成员，要访问非静态成员，必须依赖于外部类的实例对象<br>eg:</p><pre><code class="java">public class test11_student &#123;    class Test&#123;        int num;        public int getNum()&#123;            return num;        &#125;    &#125;    public static void main(String[] args) &#123;        test11_student test = new test11_student();        Test a = test.new Test();        a.num = 10;        System.out.println(a.getNum());    &#125;&#125;```he</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于c++与俄罗斯方块</title>
      <link href="/2022/12/25/qst%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/12/25/qst%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于c-与俄罗斯方块"><a href="#关于c-与俄罗斯方块" class="headerlink" title="关于c++与俄罗斯方块"></a>关于c++与俄罗斯方块</h1><p>emm浅谈一下自己用c++写的第一个小项目俄罗斯方块中遇到的困难</p><h2 id="1-关于easyx图形库"><a href="#1-关于easyx图形库" class="headerlink" title="1. 关于easyx图形库"></a>1. 关于easyx图形库<br></h2><ul><li><h4 id="头文件-lt-graphics-h-gt"><a href="#头文件-lt-graphics-h-gt" class="headerlink" title="头文件&lt;graphics.h&gt;"></a>头文件&lt;graphics.h&gt;</h4></li><li><h4 id="关于最后阶段做的game-over图片与you-winer图片在游戏结束后不显示的问题"><a href="#关于最后阶段做的game-over图片与you-winer图片在游戏结束后不显示的问题" class="headerlink" title="关于最后阶段做的game over图片与you winer图片在游戏结束后不显示的问题"></a>关于最后阶段做的game over图片与you winer图片在游戏结束后不显示的问题<br></h4>  刚开始百度以为是图片位深或者路径的问题，emm，但是在测试程序中如使用下代码<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMAGE imgOver;</span><br><span class="line">    IMAGE imgWin;</span><br><span class="line">    IMAGE imgBg;</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgOver, <span class="string">&quot;res/over.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgBg, <span class="string">&quot;res/bg.png&quot;</span>);</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgWin, <span class="string">&quot;res/win.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgWin);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">发现无论是 **imgWin** 在下还是 **imgOver** 都能很好的覆盖之前的图片，这说明之前的假设是错误滴&lt;br&gt;</span><br><span class="line">emm最后翻找了一下代码发现相比于测试程序，我的源代码 **Tetris** 类中的 **play** 方法这一段</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">if</span> (gameOver) &#123;</span><br><span class="line">    <span class="comment">// 保存分数</span></span><br><span class="line">    <span class="built_in">saveScore</span>();</span><br><span class="line">    <span class="comment">// 更新游戏界面</span></span><br><span class="line">    <span class="built_in">displayOver</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closegraph</span>();<span class="comment">// 没关闭窗口之前无法显示游戏结束图片</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 重新开局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  缺少了 <strong>closegraph()</strong> 函数，加上之后确实解决了问题，但是在测试程序中如下代码<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);<span class="comment">// 这里并没有出现源代码那样不显示直接跳过图片的情况</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>  发现好像不加也不会出什么错，给整不会了，在这里记录一下这个小问题<h2 id="2-关于收获"><a href="#2-关于收获" class="headerlink" title="2. 关于收获"></a>2. 关于收获</h2></li><li><h4 id="行的清除与保存"><a href="#行的清除与保存" class="headerlink" title="行的清除与保存"></a>行的清除与保存<br></h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tetris::clearLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lines = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = rows - <span class="number">1</span>;<span class="comment">// 存储数据的行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 检查第i行是否满行</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            map[k][j] = map[i][j];<span class="comment">// 一边扫描一边存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; cols) &#123;</span><br><span class="line">            <span class="comment">// 不是满行</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 满行</span></span><br><span class="line">            lines++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  初次接触感觉很巧妙这个方法，用 <strong>count</strong> 变量存储非空位置的个数，通过 <strong>if else</strong> 条件判断语句和变量 <strong>k</strong> 实现从下向上每行数据的存储<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[k][j] = map[i][j];</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &lt; cols) &#123;</span><br><span class="line">            <span class="comment">// 不是满行</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>  这两行是精髓，如果不是满行则改为对上面一行进行判断</li><li><h4 id="如何脑袋空空开始设计程序"><a href="#如何脑袋空空开始设计程序" class="headerlink" title="如何脑袋空空开始设计程序"></a>如何脑袋空空开始设计程序</h4>  先设计类和程序接口，不要一上来就执着与具体方法的实现</li><li><h4 id="关于方块"><a href="#关于方块" class="headerlink" title="关于方块"></a>关于方块</h4>  首先看一下定义的 <strong>block</strong> 类<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Block</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveLeftRight</span><span class="params">(<span class="type">int</span> offset)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> leftMargin, <span class="type">int</span> topMargin)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> IMAGE** <span class="title">getImages</span><span class="params">()</span></span>;</span><br><span class="line">    Block&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Block&amp; other);</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">blockInMap</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solidify</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBlockType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> blockType;</span><br><span class="line">    Point smallBlocks[<span class="number">4</span>];<span class="comment">// 俄罗斯方块的四个小方块</span></span><br><span class="line">    IMAGE *img;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义七个指针分别指向七个不同颜色方块可以重复渲染</span></span><br><span class="line">    <span class="comment">// 一个imgs里的元素代表一种颜色的一个小方块</span></span><br><span class="line">    <span class="type">static</span> IMAGE* imgs[<span class="number">7</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  注意这里<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> IMAGE** <span class="title">getImages</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>  为什么 <strong>getImages()</strong> 方法的返回值是 <strong>IMAGE**</strong>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMAGE** <span class="title">Block::getImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> imgs;<span class="comment">// 返回数组，数组名是指针，所以返回值类型为IMAGE**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <strong>返回数组，数组名是指针，所以返回值类型为IMAGE**</strong><br><br>  通过方法 <strong>blockInMap</strong> 将 <strong>point</strong> 类的 <strong>smallBlocks</strong> 与数组 <strong>map</strong> 联系起来  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Block::blockInMap</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = map.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cols = map[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (smallBlocks[i].col &lt; <span class="number">0</span> || smallBlocks[i].col &gt;= cols ||</span><br><span class="line">            smallBlocks[i].row &lt; <span class="number">0</span> || smallBlocks[i].row &gt;= rows ||</span><br><span class="line">            map[smallBlocks[i].row][smallBlocks[i].col]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  通过 <strong>solidify</strong> 方法对 <strong>map</strong> 中的数值修改为 <strong>blockType</strong> 来达到固化方块的效果   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Block::solidify</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 设置标记固化对应位置</span></span><br><span class="line">        map[smallBlocks[i].row][smallBlocks[i].col] = blockType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于更改方块初始生成位置的问题"><a href="#关于更改方块初始生成位置的问题" class="headerlink" title="关于更改方块初始生成位置的问题"></a>关于更改方块初始生成位置的问题</h4>  发现方块无法向初始位置的左边移动，好像方块的初始位置就是地图的最左端<br><br>  原始正常代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一种颜色的方块绘制图形</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Block::draw</span><span class="params">(<span class="type">int</span> leftMargin, <span class="type">int</span> topMargin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = leftMargin + smallBlocks[i].col * size;</span><br><span class="line">        <span class="type">int</span> y = topMargin + smallBlocks[i].row * size;</span><br><span class="line">        <span class="built_in">putimage</span>(x, y, img);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  此时方块的初始位置在屏幕的最左边，此时想让方块的初始位置在屏幕的中间<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = leftMargin + <span class="number">4</span> * size + smallBlocks[i].col * size;</span><br></pre></td></tr></table></figure>  于是修改了 <strong>x</strong><br><br>  这导致方块在下落过程中无法向开始位置的左边移动，因为每次调用 <strong>draw</strong>， <strong>x</strong> 都会加上 **(leftMargin + 4 * size)**，但是下落到底部之后又会回到它本来应该在的位置，感觉像是在调用 <strong>draw</strong> 的时候把所有的方块都画的偏移了，但方块自身的位置并没有变<br><h4 id="渲染方块的循环"><a href="#渲染方块的循环" class="headerlink" title="渲染方块的循环"></a>渲染方块的循环</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = j * blockSize + leftMargin;</span><br><span class="line"><span class="type">int</span> y = i * blockSize + topMargin;</span><br><span class="line"><span class="built_in">putimage</span>(x, y, imgs[map[i][j] - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  遍历地图检查每个位置是否为0，为0证明没有方块，则不渲染方块 <strong>(continue)</strong> ,不为0则渲染对应的方块类型<br><br>   <strong>(注意: 这里只是渲染已经固化的方块类型,这也解释了为什么方块掉落时位置与固化之后渲染的位置不一样)</strong> <br><br>  所以在后面加上这两段代码来渲染当前正在下落的方块和预告的下一个方块  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   curBlock-&gt;<span class="built_in">draw</span>(leftMargin, topMargin);</span><br><span class="line">nextBlock-&gt;<span class="built_in">draw</span>(leftMargin + <span class="number">12</span> * <span class="number">36</span> , topMargin);</span><br></pre></td></tr></table></figure>  绕了一圈发现巨简单的方法只要在初始化小方块的时候让它偏移到中间就可以了   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 初始化smallBlocks</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定是哪种组合方块</span></span><br><span class="line"><span class="type">int</span> value = blocks[blockType - <span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定组合方块中每个小方块的x坐标和y坐标</span></span><br><span class="line">smallBlocks[i].row = value / <span class="number">2</span>;</span><br><span class="line">smallBlocks[i].col = value % <span class="number">2</span> + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  emmmmmmmmmmmmmmmmmmmm………..<br></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 项目解析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
