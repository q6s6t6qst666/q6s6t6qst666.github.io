<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Java类的组合</title>
      <link href="/2023/04/11/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/"/>
      <url>/2023/04/11/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="组合的概念"><a href="#组合的概念" class="headerlink" title="组合的概念"></a>组合的概念</h1><p>Java的类中可以有其他类的对象作为成员，这便是类的组合</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java单例模式</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java注解与反射</title>
      <link href="/2023/04/10/%E5%85%B3%E4%BA%8EJava%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/04/10/%E5%85%B3%E4%BA%8EJava%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其实同 classs 和 interface 一样，注解也属于一种类型</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li>@override：此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个发方法声明</li><li>@Deprecated：此注释可用于修饰方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者有更好的选择</li><li>@SupressWarnings：用来抑制编译时的警告信息（<strong>注意：此注释需要添加一个参数才能正确使用</strong>）<ul><li>@SupressWarnings(“all”)</li><li>@SupressWarnings(“unchecked”)</li><li>@SupressWarnings(value={“unchecked”,”deprecation”})</li><li>等等……</li></ul></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li>使用 @interface 来自定义注解，其自动继承java.lang.annotation.Annotation接口</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数类型（返回值只能是基本类型，Class，String，enum）</li><li>可以用default来声明参数的默认值</li><li>如果注解只有一个参数成员，一般参数名是value</li><li>注解元素必须要有值，定义注解元素是，经常使用空 字符串/0 作为默认值</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面</p><p>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种(这些类在包java.lang.annotation中)</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明@Retention也需要参数，类似于@SupressWarnings</p><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间</p><p>它的取值如下：</p><table><thead><tr><th align="left">RetentionPolicy.SOURCE</th><th align="center">注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视</th></tr></thead><tbody><tr><td align="left">RetentionPolicy.CLASS</td><td align="center">注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</td></tr><tr><td align="left">RetentionPolicy.RUNTIME</td><td align="center">注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</td></tr></tbody></table><ul><li><strong>SOURCE &lt; CLASS &lt; RUNTIME</strong></li></ul><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target 指定了注解运用的地方，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景</p><p>@Target源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Module declaration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MODULE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明@Target也需要参数，类似于@SupressWarnings</p><p>它的取值如下：</p><table><thead><tr><th align="left">ElementType.ANNOTATION_TYPE</th><th align="center">可以给一个注解进行注解</th></tr></thead><tbody><tr><td align="left">ElementType.CONSTRUCTOR</td><td align="center">可以给构造方法进行注解</td></tr><tr><td align="left">ElementType.FIELD</td><td align="center">可以给属性进行注解</td></tr><tr><td align="left">ElementType.LOCAL_VARIABLE</td><td align="center">可以给局部变量进行注解</td></tr><tr><td align="left">ElementType.METHOD</td><td align="center">可以给方法进行注解</td></tr><tr><td align="left">ElementType.PACKAGE</td><td align="center">可以给一个包进行注解</td></tr><tr><td align="left">ElementType.PARAMETER</td><td align="center">可以给一个方法内的参数进行注解</td></tr><tr><td align="left">ElementType.TYPE</td><td align="center">可以给一个类型进行注解，比如类、接口、枚举</td></tr></tbody></table><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解</p><p>举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>它的作用是能够将注解中的元素包含到 <strong>Javadoc</strong> 中去</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><h2 id="反射（Java-Reflection）"><a href="#反射（Java-Reflection）" class="headerlink" title="反射（Java Reflection）"></a>反射（Java Reflection）</h2><p>反射机制允许程序在执行期借助于Reflection API获得任何类的内部信息，并且能直接操作任意对象的内部属性及方法</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子可以看到类的结构）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String（包名.类名）&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java装箱与拆箱</title>
      <link href="/2023/04/05/%E5%85%B3%E4%BA%8Ejava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
      <url>/2023/04/05/%E5%85%B3%E4%BA%8Ejava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是自动装箱与拆箱"><a href="#什么是自动装箱与拆箱" class="headerlink" title="什么是自动装箱与拆箱"></a>什么是自动装箱与拆箱</h2><h4 id="1-来由"><a href="#1-来由" class="headerlink" title="1. 来由"></a>1. 来由</h4><ul><li>Java是一种面向对象编程的语言，但他同时也提供了基本数据类型，提供基本数据类型是出于性能方面的考虑：<strong>因为使用对象来处理即使是最简单的计算，系统也销也比较大</strong>(why?)</li><li>Java中的基本数据类型没有方法和属性，但是在特定场景下，我们必须要利用对象的相关属性，而包装类就是为了让基本数据类型拥有方法和属性，实现对象化交互</li></ul><h4 id="2-Java中的基本数据类型"><a href="#2-Java中的基本数据类型" class="headerlink" title="2. Java中的基本数据类型"></a>2. Java中的基本数据类型</h4><p>java中有8种基本数据类型，分别为：</p><ul><li>数字类型（6种）<ul><li>整型<ul><li>byte——————–1字节= 8bit</li><li>short——————-2字节=16bit</li><li>int———————–4字节= 32bit</li><li>long——————–8字节= 64bit</li></ul></li><li>浮点型<ul><li>float——————-4字节=32bit</li><li>double—————-8字节=64bit</li></ul></li></ul></li><li>字符类型（1种）：char—–2字节=16bit</li><li>boolean类型（1种）：boolean类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。boolean类型占用存储空间官方未定义</li></ul><h5 id="注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c-c-不同）"><a href="#注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c-c-不同）" class="headerlink" title="注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c/c++不同）"></a>注：在Java中，所有的数值类型所占据的字节数量是不变的，其不会随着机器硬件的变化而改变，而且Java中没有任何无符号类型（unsigned）（与c/c++不同）</h5><h4 id="3-类型封装器（包装类）"><a href="#3-类型封装器（包装类）" class="headerlink" title="3. 类型封装器（包装类）"></a>3. 类型封装器（包装类）</h4><p>上面说的八种基本数据类型都分别都有对应的包装类，如下表：需要了解的是这些包装类提供了大量的方法，通过这些方法可以完全将基本类型集成到Java的对象层次中</p><h4 id="4-自动装箱与拆箱"><a href="#4-自动装箱与拆箱" class="headerlink" title="4. 自动装箱与拆箱"></a>4. 自动装箱与拆箱</h4><h5 id="4-1-自动装箱"><a href="#4-1-自动装箱" class="headerlink" title="4.1 自动装箱"></a>4.1 自动装箱</h5><p>装箱 ：就是将基本数据类型用他们对应的包装类包装起来。如下：</p><h5 id="4-1-自动拆箱"><a href="#4-1-自动拆箱" class="headerlink" title="4.1 自动拆箱"></a>4.1 自动拆箱</h5><p>拆箱 ： 就是将包装类型转换为基本数据类型。如下</p><p>因此总结一下装箱和拆箱的实现过程就是：</p><p>装箱过程是通过调用包装类的valueOf方法实现的，而拆箱过程是通过调用包装类的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><p>注意：我们要了解的是，频繁的装箱拆箱的话，会增加内存的消耗，影响性能</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java枚举类</title>
      <link href="/2023/04/04/%E5%85%B3%E4%BA%8EJava%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2023/04/04/%E5%85%B3%E4%BA%8EJava%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-枚举-enum"><a href="#Java-枚举-enum" class="headerlink" title="Java 枚举(enum)"></a>Java 枚举(enum)</h1><h3 id="枚举类的目的"><a href="#枚举类的目的" class="headerlink" title="枚举类的目的"></a>枚举类的目的</h3><p><strong>实现一个类只有固定的几个对象，而且不能随意创建对象</strong></p><h4 id="枚举类的早期实现方式"><a href="#枚举类的早期实现方式" class="headerlink" title="枚举类的早期实现方式"></a>枚举类的早期实现方式</h4><ul><li>构造器加private私有化(使用私有构造方法后类外无法访问构造方法，从而无法创建类)</li><li>本类内部创建一组常量对象，并添加public static修饰符，对外暴露这些常量对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有固定4个对象的季节类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String seasonName;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在JDK1.5之后，Java支持enum关键字来快速的定义枚举类型</li><li>枚举类型本质上也是一种类，只不过是这个类的对象是固定的几个，而不能随意让用户创建</li></ul><h3 id="枚举类的定义"><a href="#枚举类的定义" class="headerlink" title="枚举类的定义"></a>枚举类的定义</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的要求和特点"><a href="#枚举类的要求和特点" class="headerlink" title="枚举类的要求和特点"></a>枚举类的要求和特点</h3><ul><li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写</li><li>如果常量对象列表后面没有其他代码，那么“；”<strong>可以省略</strong>，否则不可以省略“；”</li><li><strong>编译器给枚举类默认提供private的无参构造</strong>（枚举类依靠此来达成“实现一个类只有固定的几个对象，而且不能随意创建对象”的目的）</li><li>如果需要也可以定义有参构造，默认也是private修饰，常量对象名后面加(实参列表)调用有参构造器</li><li>枚举类默认继承自java.lang.Enum类，不能再继承其他的类型；枚举类默认是final修饰的也不能被继承</li><li>JDK1.5之后switch，提供支持枚举类型，case后面可以写枚举常量名</li><li>枚举类型如有其它属性，建议这些属性也声明为final的，因为<strong>常量对象在逻辑意义上应该不可变</strong></li><li>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它<br>枚举类eg:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">   &#123;</span><br><span class="line">       RED, GREEN, BLUE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>枚举类的内部实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的常用方法"><a href="#枚举类的常用方法" class="headerlink" title="枚举类的常用方法"></a>枚举类的常用方法</h3></li><li>values()：以数组形式返回枚举类型的所有成员</li><li>valueOf()：将普通字符串转换为枚举实例</li><li>ordinal()：获取枚举成员的索引位置</li><li>toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</li></ul><p>测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RED at index <span class="number">0</span></span><br><span class="line">GREEN at index <span class="number">1</span></span><br><span class="line">BLUE at index <span class="number">2</span></span><br><span class="line">RED</span><br></pre></td></tr></table></figure><ul><li>枚举常量也可以有自己的方法。此时要注意<strong>必须在枚举实例的最后一个成员后添加分号</strong>，而且<strong>必须先定义枚举实例</strong></li></ul><h3 id="枚举类的用法"><a href="#枚举类的用法" class="headerlink" title="枚举类的用法"></a>枚举类的用法</h3><ul><li>接口组织枚举</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java泛型</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><ul><li>使用类型参数，使程序更为通用，适用于处理不同类型的数据</li><li>泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数</li><li>可以声明泛型类、泛型方法和泛型接口</li><li>没有泛型的时候使用集合<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">names</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        names.add(<span class="string">&quot;qst&quot;</span>);</span><br><span class="line">        names.add(<span class="number">123</span>); <span class="comment">//编译正常</span></span><br><span class="line">        System.out.println(names.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></li><li>有泛型的情况下使用集合<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;qst&quot;</span>);</span><br><span class="line">        names.add(<span class="number">123</span>); <span class="comment">//编译不通过</span></span><br><span class="line">        System.out.println(names.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>有了泛型后，定义好的集合names在编译的时候add(123)就会编译不通过<br>相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性</li></ul><h3 id="泛型中KTVE的含义"><a href="#泛型中KTVE的含义" class="headerlink" title="泛型中KTVE的含义"></a>泛型中KTVE的含义</h3><ul><li>T: Type任意类型</li><li>E：Element (在集合中使用，因为集合中存放的是元素)</li><li>K：Key（键）</li><li>V：Value（值）</li><li>N：Number（数值类型）N：Number（数值类型）</li><li>？：表示不确定的java类型</li></ul><hr><h4 id="注意：-泛型类不支持基本数据类型"><a href="#注意：-泛型类不支持基本数据类型" class="headerlink" title="注意： 泛型类不支持基本数据类型"></a>注意： 泛型类不支持基本数据类型</h4><hr><h3 id="泛型类派生子类"><a href="#泛型类派生子类" class="headerlink" title="泛型类派生子类"></a>泛型类派生子类</h3><ul><li>子类是泛型类：子类数据类型中要有父类的数据类型</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span>&lt;T, E, k, ...&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类不是泛型类：要明确父类的数据类型(不指明就默认Object数据类型)</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 &lt;泛型标识, 泛型标识, ...&gt;&#123;</span><br><span class="line">    泛型标识 方法名();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口的使用"><a href="#泛型接口的使用" class="headerlink" title="泛型接口的使用"></a>泛型接口的使用</h4><ol><li>实现类不是泛型类，接口要明确数据类型(不指明就默认Object数据类型)</li><li>实现类也是泛型类，实现类的接口要有泛型类的泛型标识 </li></ol><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在调用方法的时候指明泛型的具体类型</p><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T, E, ...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line"><span class="comment">//泛型标识可以与类内的相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错"><a href="#注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错" class="headerlink" title="注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错"></a>注意：返回值为泛型的成员方法不能声明为static，泛型方法可以，因为泛型类在创建对象的时候要指定类型，而静态方法时通过类名直接调用，并且在创建对象之前就有静态方法，此时成员方法类型还未被指定，所以会报错</h4><hr><h3 id="泛型的可变参数"><a href="#泛型的可变参数" class="headerlink" title="泛型的可变参数"></a>泛型的可变参数</h3><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E... e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E e1 : e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><ul><li>类型通配符 “?” 用来代替具体的类型实参</li><li>类型通配符是实参类型，不是形参类型<br>eg:</li></ul><p>定义Box类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;Number&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>修改test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line">        Box&lt;Integer&gt; box2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box2.setFirst(<span class="number">200</span>);</span><br><span class="line">        showBox(box2);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;Number&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现代码第8行报错，原因是形参是Box<Number>类型，实参却是Box<Integer>类型</p><p>改正test01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Number&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box1.setFirst(<span class="number">100</span>);</span><br><span class="line">        showBox(box1);</span><br><span class="line">        Box&lt;Integer&gt; box2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        box2.setFirst(<span class="number">200</span>);</span><br><span class="line">        showBox(box2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBox</span><span class="params">(Box&lt;?&gt; box)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> box.getFirst();<span class="comment">//注意</span></span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型通配符的上限"><a href="#类型通配符的上限" class="headerlink" title="类型通配符的上限"></a>类型通配符的上限</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? extends 实参类型&gt;</span><br></pre></td></tr></table></figure><p>要求该泛型类型只能是实参类型或者实参类型的子类型</p><hr><p>注意：上线通配符的集合不能添加元素</p><hr><h4 id="类型通配符的下限"><a href="#类型通配符的下限" class="headerlink" title="类型通配符的下限"></a>类型通配符的下限</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? <span class="built_in">super</span> 实参类型&gt;</span><br></pre></td></tr></table></figure><p>要求该泛型类型只能是实参类型或者实参类型的父类型</p><hr><p>注意：下限通配符的集合可以添加元素，但是不能保证对元素类型的约束（可以填充子类类型）</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java抽象类&amp;interface</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;interface/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;interface/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><ul><li>在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>而抽象方法,是指没有方法体的方法,同时抽象方法还必须使用关键字abstract做修饰。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在后日子类进行重用，进行具体化</li><li>所以，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法</li><li>拥有抽象方法的类就是抽象类（但抽象类中也可以不包含抽象方法），抽象类要使用abstract关键字声明<h4 id="抽象类的特性和使用"><a href="#抽象类的特性和使用" class="headerlink" title="抽象类的特性和使用"></a>抽象类的特性和使用</h4></li><li>抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了</li><li>抽象类的使用必须有子类，使用extends继承，一个子类只能继承一个抽象类</li><li>子类（如果不是抽象类）则必须<strong>覆写</strong>抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）</li><li>抽象类可以不包含抽象方法，但如果类中包含抽象方法，就必须将该类声明为抽象类<h4 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h4></li><li>抽象类可以有构造方法，且依然满足先执行父类构造，再执行子类构造的顺序</li><li>抽象类不能使用final声明，因为抽象类必须有子类，而final定义的类不能有子类</li><li>外部抽象类不允许使用static声明，而内部的抽象类可以使用static声明。<br>使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称</li><li>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2></li><li>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，<strong>Java不支持多重继承</strong>。有了接口，就可以得到<strong>多重继承</strong>的效果</li><li>从本质上讲，接口是一种<strong>特殊的抽象类</strong>，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现</li><li>也可以理解成：<strong>接口(interface)是抽象方法和常量值的定义的集合</strong></li><li>接口也可以继承另一个接口，使用extends关键字</li><li>接口方法没有主体-主体由”implement”类提供<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4></li><li>如果一个类中，既有抽象方法，又有非抽象方法，那么该类只能定义为抽象类，不能定义为接口</li><li>如果一个类中，只有抽象方法，没有非抽象方法，那么该类可以定义为接口，一般就定义为接口</li><li>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类<h4 id="接口中的成员变量"><a href="#接口中的成员变量" class="headerlink" title="接口中的成员变量"></a>接口中的成员变量</h4></li><li>方法和属性默认都是public修饰，也可以使用protected，但不能用private（private无法继承）</li><li>所有的属性都是静态的常量，默认省略了static和final修饰符，属性的值必须实例化（初始化）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java类继承</title>
      <link href="/2023/04/03/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/04/03/%E5%85%B3%E4%BA%8EJava%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="属性隐藏"><a href="#属性隐藏" class="headerlink" title="属性隐藏"></a>属性隐藏</h2><p>子类中声明了与超类中相同的成员变量名</p><ul><li>从超类继承的变量将被隐藏</li><li>子类拥有了两个相同名字的变量，一个继承自超类，另一个由自己声明</li><li>当子类执行继承自超类的操作时，处理的是继承自超类的变量，而当子类执行它</li><li>自己声明的方法时，所操作的就是它自己声明的变量<h2 id="访问被隐藏的超类属性"><a href="#访问被隐藏的超类属性" class="headerlink" title="访问被隐藏的超类属性"></a>访问被隐藏的超类属性</h2>本类中声明的方法使用“super.属性”访问从超类继承的属性<h2 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h2><h3 id="如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖"><a href="#如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖" class="headerlink" title="如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖"></a>如果子类不需使用从超类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖</h3></li><li>覆盖方法的返回类型，方法名称，参数的个数及类型必须和被覆盖的方法一摸一样</li><li>覆盖方法的访问权限可以比被覆盖的宽松，但是不能更为严格<h3 id="Java-Override注解"><a href="#Java-Override注解" class="headerlink" title="Java @Override注解"></a>Java @Override注解</h3>@Override 的作用是告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否则就会编译出错。这样可以帮助程序员避免一些低级错误<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">t0String</span><span class="params">()</span> &#123; <span class="comment">//toString()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述代码第 6 行是重写 Object 类的 toString() 方法，该方法使用 @Override 注解。如果 toString() 不小心写成了 t0String()，那么程序会发生编译错误。会有如下的代码提示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型为 Person 的方法t0String()必须覆盖或实现超类型方法</span><br></pre></td></tr></table></figure><h3 id="方法覆盖的注意事项"><a href="#方法覆盖的注意事项" class="headerlink" title="方法覆盖的注意事项"></a>方法覆盖的注意事项</h3></li><li>不能覆盖的方法<ul><li>基类中声明为final的终结方法</li><li>基类中声明为static 的静态方法</li></ul></li><li>调用被覆盖的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.overriddenMethodName();</span><br></pre></td></tr></table></figure><h2 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h2><h3 id="有继承时子类的构造方法遵循以下的原则"><a href="#有继承时子类的构造方法遵循以下的原则" class="headerlink" title="有继承时子类的构造方法遵循以下的原则"></a>有继承时子类的构造方法遵循以下的原则</h3></li><li>子类不能从超类继承构造方法</li><li>最好在子类的构造方法中使用super关键字显式调用超类的某个构造方法，调用语句必须出现在子类构造方法的第一行</li><li>如子类构造方法体中没有显式调用超类构造方法，则系统在执行子类的构造方法时会自动调用超类的默认构造方法（即无参的构造方法）<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2></li><li>所有Java类的直接或间接超类</li><li>如果一个类没有继承任何超类，那么就隐含直接继承了Object类<h3 id="相等和同一"><a href="#相等和同一" class="headerlink" title="相等和同一"></a>相等和同一</h3></li><li>两个对象具有相同的类型，及相同的属性值，则称二者相等(equal)</li><li>如果两个引用变量指向的是同一个对象，则称这两个引用变量同一(identical)</li><li>在Object类中声明的equals()方法功能是比较两个对象引用是否指向同一对象，而不是比较两个引用指向的对象是否相等</li><li>比较运算符“==” 判断的是这两个对象是否同一</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2023/03/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>线程是调度的基本单位<br>一个进程可能包含多个线程，一个进程的多个线程共享进程的资源<br>进程是操作系统分配资源的基本单位<br>线程在进程的基础上进一步提高了系统的并发性<br>进程相对线程，降低了创建调度和撤销的成本</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java代码块</title>
      <link href="/2023/03/27/%E5%85%B3%E4%BA%8EJava%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2023/03/27/%E5%85%B3%E4%BA%8EJava%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="static代码块和构造代码块"><a href="#static代码块和构造代码块" class="headerlink" title="static代码块和构造代码块"></a>static代码块和构造代码块</h1><p>结论:<strong>static代码块伴随着类的加载，只在类第一次被加载的时候调用一次<br>构造代码块是用来给新建的对象进行初始化的，构造几个对象，就调用多少次，是通用的<br>局部代码块是用于特定局部的一种代码，在执行完局部代码之后，就被释放掉了</strong><br></p><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCode</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// static 代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construction code &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    StaticCode(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        System.out.println(<span class="string">&quot;construction method： &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age=<span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;method show:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"><span class="keyword">import</span> edu.bupt.qst.StaticCode;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        StaticCode p2=<span class="keyword">new</span> <span class="title class_">StaticCode</span>(<span class="number">40</span>);</span><br><span class="line">        StaticCode p1=<span class="keyword">new</span> <span class="title class_">StaticCode</span>(<span class="number">20</span>);</span><br><span class="line">        p1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/ppgUFds"><img src="https://s1.ax1x.com/2023/03/29/ppgUFds.png" alt="ppgUFds.png"></a></p><h1 id="构造代码块和构造方法"><a href="#构造代码块和构造方法" class="headerlink" title="构造代码块和构造方法"></a>构造代码块和构造方法</h1><p>结论:<strong><br>构造代码块<br>特点：对象一建立就运行了，而且优先于构造函数执行<br>作用：给对象进行初始化<br>构造代码块与构造方法区别：<br>构造代码块是给所有的对象进行统一的初始化(每次创建对象必调用)<br>构造方法是对应的对象进行初始化</strong></p><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.bupt.qst;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&quot;小虎鲸&quot;</span>);</span><br><span class="line">        System.out.println(A.name);</span><br><span class="line">        System.out.println(B.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    Person2() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    Person2(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgloc.com/i/ikebHy"><img src="https://i.328888.xyz/2023/03/29/ikebHy.png" alt="ikebHy.png"></a></p><h1 id="静态-内部类-方法"><a href="#静态-内部类-方法" class="headerlink" title="(静态)内部类/方法"></a>(静态)内部类/方法</h1><p>静态内部类/方法 只能访问外部类中的静态成员，要访问非静态成员，必须依赖于外部类的实例对象<br>eg:</p><pre><code class="java">public class test11_student &#123;    class Test&#123;        int num;        public int getNum()&#123;            return num;        &#125;    &#125;    public static void main(String[] args) &#123;        test11_student test = new test11_student();        Test a = test.new Test();        a.num = 10;        System.out.println(a.getNum());    &#125;&#125;```he</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于c++与俄罗斯方块</title>
      <link href="/2022/12/25/qst%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/12/25/qst%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于c-与俄罗斯方块"><a href="#关于c-与俄罗斯方块" class="headerlink" title="关于c++与俄罗斯方块"></a>关于c++与俄罗斯方块</h1><p>emm浅谈一下自己用c++写的第一个小项目俄罗斯方块中遇到的困难</p><h2 id="1-关于easyx图形库"><a href="#1-关于easyx图形库" class="headerlink" title="1. 关于easyx图形库"></a>1. 关于easyx图形库<br></h2><ul><li><h4 id="头文件-lt-graphics-h-gt"><a href="#头文件-lt-graphics-h-gt" class="headerlink" title="头文件&lt;graphics.h&gt;"></a>头文件&lt;graphics.h&gt;</h4></li><li><h4 id="关于最后阶段做的game-over图片与you-winer图片在游戏结束后不显示的问题"><a href="#关于最后阶段做的game-over图片与you-winer图片在游戏结束后不显示的问题" class="headerlink" title="关于最后阶段做的game over图片与you winer图片在游戏结束后不显示的问题"></a>关于最后阶段做的game over图片与you winer图片在游戏结束后不显示的问题<br></h4>  刚开始百度以为是图片位深或者路径的问题，emm，但是在测试程序中如使用下代码<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMAGE imgOver;</span><br><span class="line">    IMAGE imgWin;</span><br><span class="line">    IMAGE imgBg;</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgOver, <span class="string">&quot;res/over.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgBg, <span class="string">&quot;res/bg.png&quot;</span>);</span><br><span class="line">    <span class="built_in">loadimage</span>(&amp;imgWin, <span class="string">&quot;res/win.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line">    <span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgWin);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">发现无论是 **imgWin** 在下还是 **imgOver** 都能很好的覆盖之前的图片，这说明之前的假设是错误滴&lt;br&gt;</span><br><span class="line">emm最后翻找了一下代码发现相比于测试程序，我的源代码 **Tetris** 类中的 **play** 方法这一段</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">if</span> (gameOver) &#123;</span><br><span class="line">    <span class="comment">// 保存分数</span></span><br><span class="line">    <span class="built_in">saveScore</span>();</span><br><span class="line">    <span class="comment">// 更新游戏界面</span></span><br><span class="line">    <span class="built_in">displayOver</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closegraph</span>();<span class="comment">// 没关闭窗口之前无法显示游戏结束图片</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 重新开局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  缺少了 <strong>closegraph()</strong> 函数，加上之后确实解决了问题，但是在测试程序中如下代码<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);<span class="comment">// 这里并没有出现源代码那样不显示直接跳过图片的情况</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBg);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgOver);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>  发现好像不加也不会出什么错，给整不会了，在这里记录一下这个小问题<h2 id="2-关于收获"><a href="#2-关于收获" class="headerlink" title="2. 关于收获"></a>2. 关于收获</h2></li><li><h4 id="行的清除与保存"><a href="#行的清除与保存" class="headerlink" title="行的清除与保存"></a>行的清除与保存<br></h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tetris::clearLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lines = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = rows - <span class="number">1</span>;<span class="comment">// 存储数据的行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 检查第i行是否满行</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            map[k][j] = map[i][j];<span class="comment">// 一边扫描一边存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; cols) &#123;</span><br><span class="line">            <span class="comment">// 不是满行</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 满行</span></span><br><span class="line">            lines++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  初次接触感觉很巧妙这个方法，用 <strong>count</strong> 变量存储非空位置的个数，通过 <strong>if else</strong> 条件判断语句和变量 <strong>k</strong> 实现从下向上每行数据的存储<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[k][j] = map[i][j];</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &lt; cols) &#123;</span><br><span class="line">            <span class="comment">// 不是满行</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>  这两行是精髓，如果不是满行则改为对上面一行进行判断</li><li><h4 id="如何脑袋空空开始设计程序"><a href="#如何脑袋空空开始设计程序" class="headerlink" title="如何脑袋空空开始设计程序"></a>如何脑袋空空开始设计程序</h4>  先设计类和程序接口，不要一上来就执着与具体方法的实现</li><li><h4 id="关于方块"><a href="#关于方块" class="headerlink" title="关于方块"></a>关于方块</h4>  首先看一下定义的 <strong>block</strong> 类<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Block</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveLeftRight</span><span class="params">(<span class="type">int</span> offset)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> leftMargin, <span class="type">int</span> topMargin)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> IMAGE** <span class="title">getImages</span><span class="params">()</span></span>;</span><br><span class="line">    Block&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Block&amp; other);</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">blockInMap</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solidify</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBlockType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> blockType;</span><br><span class="line">    Point smallBlocks[<span class="number">4</span>];<span class="comment">// 俄罗斯方块的四个小方块</span></span><br><span class="line">    IMAGE *img;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义七个指针分别指向七个不同颜色方块可以重复渲染</span></span><br><span class="line">    <span class="comment">// 一个imgs里的元素代表一种颜色的一个小方块</span></span><br><span class="line">    <span class="type">static</span> IMAGE* imgs[<span class="number">7</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  注意这里<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> IMAGE** <span class="title">getImages</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>  为什么 <strong>getImages()</strong> 方法的返回值是 <strong>IMAGE**</strong>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMAGE** <span class="title">Block::getImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> imgs;<span class="comment">// 返回数组，数组名是指针，所以返回值类型为IMAGE**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <strong>返回数组，数组名是指针，所以返回值类型为IMAGE**</strong><br><br>  通过方法 <strong>blockInMap</strong> 将 <strong>point</strong> 类的 <strong>smallBlocks</strong> 与数组 <strong>map</strong> 联系起来  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Block::blockInMap</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = map.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cols = map[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (smallBlocks[i].col &lt; <span class="number">0</span> || smallBlocks[i].col &gt;= cols ||</span><br><span class="line">            smallBlocks[i].row &lt; <span class="number">0</span> || smallBlocks[i].row &gt;= rows ||</span><br><span class="line">            map[smallBlocks[i].row][smallBlocks[i].col]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  通过 <strong>solidify</strong> 方法对 <strong>map</strong> 中的数值修改为 <strong>blockType</strong> 来达到固化方块的效果   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Block::solidify</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 设置标记固化对应位置</span></span><br><span class="line">        map[smallBlocks[i].row][smallBlocks[i].col] = blockType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于更改方块初始生成位置的问题"><a href="#关于更改方块初始生成位置的问题" class="headerlink" title="关于更改方块初始生成位置的问题"></a>关于更改方块初始生成位置的问题</h4>  发现方块无法向初始位置的左边移动，好像方块的初始位置就是地图的最左端<br><br>  原始正常代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一种颜色的方块绘制图形</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Block::draw</span><span class="params">(<span class="type">int</span> leftMargin, <span class="type">int</span> topMargin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = leftMargin + smallBlocks[i].col * size;</span><br><span class="line">        <span class="type">int</span> y = topMargin + smallBlocks[i].row * size;</span><br><span class="line">        <span class="built_in">putimage</span>(x, y, img);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  此时方块的初始位置在屏幕的最左边，此时想让方块的初始位置在屏幕的中间<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = leftMargin + <span class="number">4</span> * size + smallBlocks[i].col * size;</span><br></pre></td></tr></table></figure>  于是修改了 <strong>x</strong><br><br>  这导致方块在下落过程中无法向开始位置的左边移动，因为每次调用 <strong>draw</strong>， <strong>x</strong> 都会加上 **(leftMargin + 4 * size)**，但是下落到底部之后又会回到它本来应该在的位置，感觉像是在调用 <strong>draw</strong> 的时候把所有的方块都画的偏移了，但方块自身的位置并没有变<br><h4 id="渲染方块的循环"><a href="#渲染方块的循环" class="headerlink" title="渲染方块的循环"></a>渲染方块的循环</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = j * blockSize + leftMargin;</span><br><span class="line"><span class="type">int</span> y = i * blockSize + topMargin;</span><br><span class="line"><span class="built_in">putimage</span>(x, y, imgs[map[i][j] - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  遍历地图检查每个位置是否为0，为0证明没有方块，则不渲染方块 <strong>(continue)</strong> ,不为0则渲染对应的方块类型<br><br>   <strong>(注意: 这里只是渲染已经固化的方块类型,这也解释了为什么方块掉落时位置与固化之后渲染的位置不一样)</strong> <br><br>  所以在后面加上这两段代码来渲染当前正在下落的方块和预告的下一个方块  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   curBlock-&gt;<span class="built_in">draw</span>(leftMargin, topMargin);</span><br><span class="line">nextBlock-&gt;<span class="built_in">draw</span>(leftMargin + <span class="number">12</span> * <span class="number">36</span> , topMargin);</span><br></pre></td></tr></table></figure>  绕了一圈发现巨简单的方法只要在初始化小方块的时候让它偏移到中间就可以了   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 初始化smallBlocks</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定是哪种组合方块</span></span><br><span class="line"><span class="type">int</span> value = blocks[blockType - <span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定组合方块中每个小方块的x坐标和y坐标</span></span><br><span class="line">smallBlocks[i].row = value / <span class="number">2</span>;</span><br><span class="line">smallBlocks[i].col = value % <span class="number">2</span> + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  emmmmmmmmmmmmmmmmmmmm………..<br></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 项目解析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
